## 面向对象: 把合适的代码放到合适的类中

1. 简介: **写出高质量代码**

   - 特征: 封装[信息隐藏或者数据访问保护]、抽象[封装的具体实现,隐藏细节,扩展]、继承[**代码复用**,go 没有]、多态
   - [面向对象 & 面向过程](./programming-paradigm.md)
   - 面向对象分析 & 设计 & 编程
   - 接口 & 抽象
   - 组合 & 继承
   - 贫血模型 & 充血模型
   - 是很多设计原则、设计模式等编码实现的基础

2. 封装

   - What: 隐藏信息{封装变化}, 保护数据访问
   - How: 暴露有限接口及属性[需要编程语言提供访问控制的语法] & 返回不可变对象 & 抽象
   - Why: 提高代码可**维护**性; 降低接口复杂度, 提高类的**易用性**.

3. [函数载体]抽象: 接口**{能力 Flyable/Tweetable}** & 抽象类

   - What: **封装隐藏具体实现**, 使用者只需关心功能, **无需关心实现**.
   - How: 通过接口类或者抽象类实现, 特殊语法机制非必须.
   - Why: 提高代码的**扩展性**、维护性; 降低**复杂度**, 减少**细节**负担{易用}.
   - [抽象类 vs 接口{hash-a}](/se/interface/Interface.md): 抽象{oop 继承 & 模板模式 & _复用_} || 接口{约定列表 & oop 抽象 & oop 多态 & 多继承 & _解耦_ & _封装变化_ }
   - 体现: 基于接口{抽象}而非实现编程、开闭原则[对扩展开放、对修改关闭]、代码解耦[降低代码的耦合性]

4. 继承

   - What: 表示 is-a 关系, 分为单继承和多继承
   - How: 需要编程语言提供特殊语法机制. 例如 Java 的 `extends`, C++ 的 `:`
   - Why: 解决代码**复用**问题, is-a, 多态的重写{扩展性}, 但是带来了继承层次过深等阅读和维护的代价
   - solution: 组合[composition]{换 is-a}、接口{换多态}、委托{换复用}[delegation]
   - [继承 vs 组合](/se/interface/Interface.md)

5. 多态

   - What: 父类的引用指向子类的实现
   - How: 重载(接口)[静态多态] & 重写(继承)
   - Why: 提高代码**扩展**性和**复用**性

6. 实现步骤

   - 划分职责进而识别出有哪些类
   - 定义类及其属性和方法
   - 定义类与类之间的交互关系
   - 将类组装起来并提供执行入口: 上帝视角的类

7. DDD & 传统贫血模型
   - 主要是用来指导如何解耦业务系统[划分服务], 划分业务模块, 定义业务领域模型及其交互
   - 适合业务复杂的系统开发
   - 我们开发的系统业务可能都比较简单, 简单到就是基于 SQL 的 CRUD 操作, 贫血模型就足以应付这种简单业务的开发工作, 即便我们使用充血模型, 那模型本身包含的业务逻辑也并不会很多, 设计出来的领域模型也会比较单薄, 跟贫血模型差不多, 没有太大意义
   - 充血模型的设计要比贫血模型更加有难度: 充血模型是一种面向对象的编程风格, 从一开始就要设计好针对数据要暴露哪些操作, 定义哪些业务逻辑; 而不是像贫血模型那样, 我们只需要定义数据, 之后有什么功能开发需求, 我们就在 Service 层定义什么操作, 不需要事先做太多设计
   - 思维已固化, 转型有成本: 基于贫血模型的传统开发模式经历了这么多年, 已经深得人心、习以为常. 你随便问一个旁边的大龄同事, 基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的, 而且也没有出过啥大问题. 如果转向用充血模型、领域驱动设计, 那势必有一定的学习成本、转型成本. 很多人在没有遇到开发痛点的情况下, 是不愿意做这件事情的.
   - 区别
     1. 平时的开发，大部分都是 SQL 驱动: 复用性差, 扩展性差
     2. 一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中
     3. 不同的开发流程: DDD 需要事先理清楚所有的业务，定义领域模型所包含的属性和方法. 领域模型相当于可复用的业务中间层. 新功能需求的开发，都基于之前定义好的这些领域模型来完成.
     4. DDD 前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发.

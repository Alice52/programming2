## 六大设计原则

- solid + lod + 组合复用{继承组合接口抽象} + kiss + dry + YAGNI
- **迭代过程中的具体做法**:
  1. 在不添加新功能的前提下重构代码: 调整程序结果以适应新功能
  2. 实现新功能
- 基于接口而非实现编程
  1. 是一种编程原则: 通过接口引入中间层, 实现依赖关系的解耦
  2. 可以细化为多项原则:
     - 接口隔离原则[强调接口的功能单一特性,即通过分解支持功能的灵活细粒度扩展]
     - 里氏替换原则[强调接口的行为一致性,保证接口上层代码逻辑的简单性]
     - 开闭原则[强调接口的抽象特性,即通过多态特性实现功能的扩展]

### [SRP]单一原则: `高内聚`

- `相关的"在一起"叫内聚; 不相关的"在一起"叫耦合`

1. 定义:
   - 软件变化的角度, 应该仅有一个让**类/模块**变化的原因, 即每个类应该只有一个职责[把功能细化]
   - 解释: 某个类有 F1, F2 两个职责的话, 当需要修改 F1 时可能会影响 F2{使得原本正常的 F2 发生故障}}
   - 这里的职责单一并不是明文确定的规则, 在不同场景下是不一样的{**与具体的业务息息相关**}, 比如 user-info 中包含 address 信息在小系统中或者没有很多操作 address 就是符合的 srp 的, 但是如果有很多操作 address 的方法或者类似电商地址使用的话就不合符应该拆开, 所以一般不需要过度设计, 先写一个粗粒度的类{满足业务即可}+持续重构
2. feature:
   - 职责单一, 降低类的复杂度
   - 易扩展, 提高了代码的可读性, 提高系统的可维护性
   - 注意: 实际编码的过程中很难将它恰当地运用, 需要结合实际情况进行运用: 改动会很大{动物呼吸空气, 但是来了一个鱼, 不呼吸空气: 呼吸方法内判断是不是鱼[common] || 将动物分为水生和陆生[srp]}
   - 注意: 并不是越单一越好, 序列化和反序列化不宜拆成 2 个类{协议修改要两个地方, 维护性变差}
3. 判断类的职责是否足够单一
   - 类中的代码行数[200], 函数[10]或属性过多
   - 类依赖的其他类过多，或者依赖该类的其他类过多
   - 私有方法过多: 独立到新的类中使用复用
   - 难以命名: 很难用一个业务名词概括, 只能用一些笼统的 Manager、Context 之类的词语来命名
   - 类中大量的方法都是集中操作类中的某几个属性: 比如 userinfo 中的 address
4. 相关的设计模式
   - 单例

### [OCP]开闭原则: **抽象**[策略/模板]

1. 定义
   - 主体: 模块、类、方法
   - 对修改关闭[接口或抽象]: 不要修改原有代码
   - 对扩展开放[实现]: 把可能变化的内容抽象出来[oop], 而具体的实现则是可以改变和扩展的
2. feature
   - 可扩展性: 尽可能地不要修改已经写好的代码, 已有的功能, 而是去扩展它[再实现]
   - 可维护性
   - 与可读性有一定程度的违背
3. 举例: 多途径支付{策略模式}, 新增一个只会新增代码, 而不会对已有功能进行修改
4. 判断标准:
   - 只要它没有破坏原有的代码的正常运行
   - 没有破坏原有的单元测试
   - 扩展性: 封装变化, 多态, 抽象接口, **依赖注入**, 以及大部分的设计模式
5. 相关的设计模式
   - 装饰
   - 策略
   - 模板
   - **职责链**
   - 状态

### [LSP]里氏替换原则

1. 定义
   - 在任何父类出现的地方都可以用它子类来替代: **子类可以扩展父类{规范和契约}的功能, 但不能改变父类原有的功能**
   - 衍生: 尽量不要重写父类的方法, 会破坏封装性和继承体系+正方形不是长方形{扩宽的方法}
2. feature
   - **用来指导继承关系中子类该如何设计**
   - LSP 与多态不是一个含义: LSP 比多态更加严格, 比如重写父类方法并做了空校验就只符合多态而不是 LSP
   - 按照协议来设计
   - 子类的设计要保证在替换父类的时候, **不改变原有程序的逻辑以及不破坏原有程序的正确性**
   - **继承: 子类要遵守父类的行为约定[协议], 子类可以改内部逻辑但不能改行为约定**
     - 函数声明要实现的功能
     - 对输入、输出、异常的约定
     - 甚至包括注释中所罗列的任何特殊说明
3. 举例
   - 正方形不是长方形
   - 重写父类方法并做了空校验
4. 判断标准
   - 子类违背父类声明要实现的功能: 方法名
   - 子类违背父类对输入、输出、异常的约定: 本来返回 null, 子类 throw 异常 || 父类接受整数, 子类只接受正数 || 子类 throw 父类没有声明的异常
   - 子类违背父类注释中所罗列的任何特殊说明: 比如不能透支提现

### [ISP]接口分离原则

1. 定义
   - 客户端{使用者}不应该被强迫依赖它不需要的**接口**
   - 衍生: **一个类对另一个类的依赖应该建立在最小的接口上**[高内聚]
2. feature
   - 接口理解为一组 API 接口集合: 在设计微服务或者类库接口时, 如果部分接口只被部分调用者使用, 那我们就需要将这部分接口隔离出来, 单独给对应的调用者使用, 而不是强迫其他调用者也依赖这部分不会被用到的接口
   - 接口理解为单个 API 接口或函数{**接口函数的职责单一**}: 函数的设计要功能单一, 不要将多个不同的功能逻辑在一个函数中实现
   - 接口理解为 OOP 中的接口概念: 接口的设计要尽量单一, 不要让接口的实现类和调用者, 依赖不需要的接口函数
3. 举例: 安全门{防盗防水拆分成 2 个接口}
4. 接口隔离原则提供了一种判断接口的职责是否单一的标准: 通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
5. 如果接口设计过小, 则会造成接口数量过多, 使设计复杂化, 所以一定要适度
   ![avatar](/static/image/pattern/prin-interface.png)

### [DIP]依赖倒转原则

1. 相关概念
   - 依赖反转
   - 控制反转: IOC{执行流程的控制 & 流程的控制权从程序员反转到了框架}
     1. 控制反转是一个比较笼统的设计思想: 一般用来指导框架层面的设计
     2. 框架提供了一个可扩展的代码骨架: **用来组装对象, 管理整个执行流程**
     3. 程序员利用框架进行开发的时候, 只需要往预留的扩展点上, 添加跟自己业务相关的代码, 就可以利用框架来驱动整个程序流程的执行
     4. **IOC 的实现方式有 DI 和模板模式等**
   - 依赖注入: DI, Spring 也就是 DI 框架
     1. **是一种具体的编码技巧**
     2. 不通过 new() 的方式在类内部创建依赖类对象
     3. 而是将依赖的类对象在外部创建好之后
     4. 通过构造函数、函数参数等方式传递(或注入)给类使用
     5. 关注的是对象创建和类之间关系
     6. 提高扩展性, 灵活地替换依赖的类: **面向接口抽象**
   - 依赖注入框架:
     1. 我们只需要通过依赖注入框架提供的扩展点
     2. 简单配置一下所有需要创建的类对象、类与类之间的依赖关系
     3. 就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情
2. 定义
   - 高层模块**尽量**不要依赖低层模块
   - 抽象不要依赖具体实现细节, 实现细节依赖抽象
   - 所有模块都应该依赖抽象
   - 通过抽象来互相依赖: 高层如果需要依赖底层可以依赖抽象{Tomcat[高(调用 servlet)], 我们编写的代码时底层(被调用), 此时两者都依赖同一个抽象}
3. feature
   - **主要用来指导框架层面的设计**
   - 类似 控制反转
4. 依赖注入 与 基于接口编程
   - 基于接口而非实现编程是一种设计原则, 封装变化为接口, 稳定性, 低耦合, 高扩展性
   - 依赖注入是一种具体编程技巧, 关注的是对象创建和类之间关系, 目的提高了代码的扩展性, 我们可以灵活地替换依赖的类
   - 基于接口而非实现编程是让**依赖变弱**, 而依赖注入是让**依赖转移**
   - 联系: 都是基于开闭原则思路, 提高代码扩展性
5. 举例: 组装电脑时的内存条类型{内存条向上抽象一层而不是依赖某一种指定的内存条[金士顿/**]}

### KISS & YAGNI

- KISS 是如何做(简单的做); YAGNI 是决定要不要做

1. kiss 定义
   - Keep It Simple and Stupid.
   - Keep It Simple and Short.
   - Keep It Simple and Straightforward.
2. kiss feature
   - 代码可读
   - 可维护
3. kiss 原则
   - 不要使用同事可能不懂的技术来实现代码
   - 不要重复造轮子
   - 不要过度优化
4. YAGNI 定义:你不会需要它
   - 不要去设计当前用不到的功能, 不要去编写当前用不到的代码
   - 不要过度设计: 还是要预留好扩展点的

### DRY

1. 定义
   - Don’t Repeat Yourself[不要写重复的代码]
   - 并不是存在重复的代码就一定违背 DRY[有可能是语义上的不一样]
2. feature
   - 功能语义重复: 两个函数做同一件事情[isValidIp()/checkIfIpValid()], 违背了 DRY
   - 代码执行重复
   - 实现逻辑重复: 但是如果语义不同`[实现的是不同的功能不违法 DRY{可以考虑细粒度的方法抽象}]`
3. 代码的复用性
   - 代码复用性: 开发者角度, 尽量写可以被复用的代码
   - 代码复用: 使用者角度, 尽量复用可以被复用的代码
   - DRY 原则
4. 提高代码复用性
   - **复用意识**
   - **继承、多态、抽象、封装**
   - **泛型编程**
   - **Rule of Three**
   - **应用模板等设计模式**
   - 满足单一职责原则
   - 减少代码耦合
   - 通用代码下沉
   - 业务与非业务逻辑分离
   - 模块化

### [LOD]迪米特原则: **高内聚低耦合**

1. 定义
   - 最小知识原则
   - 每个模块`{类}`只应该了解那些与它关系密切的模块的有限知识
   - `||` 每个模块只和自己的*朋友*"说话"[talk], 不和陌生人"说话"[talk]
   - 翻译: **不该有直接依赖关系的类之间,不要有依赖; 有依赖关系的类之间, 尽量只依赖必要的接口[屏蔽细节]{交互}**
   - 衍生: 基于最小接口而非最大实现编程
2. feature
   - 低耦合度, 提高模块的相对独立性
3. 高内聚低耦合
   - `相关{相近的功能}的"在一起"叫内聚; 不相关的"在一起"叫耦合`
   - 高内聚用来指导类本身的设计(OOP), 低耦合用来指导类与类之间依赖关系的设计{类与类之间的依赖关系简单清晰}
   - 代码的松耦合: 依赖注入, 接口隔离, 基于接口而非实现编程, 以及迪米特法则
4. 相关的设计模式
   - 门面模式/中介模式, 软件外包, 明星/粉丝/公司 = 经纪人
   - 工厂模式: html-downloader + new document = document factory
5. 举例: 序列化和反序列化
   - [拆]迪米特: 如果有些只需要序列化或反序列化, 则不能都有, 需要拆分成两个类
   - 职责单一: 只负责序列化||反序列化, **如无必要尽量不要拆**
   - [合]高内聚低耦合: 序列化和反序列化是相似的功能, 应该考虑内聚, 把序列化和反序列化聚合到一个类中
   - 最终引入两个接口: Des + Ser + Serialization

### 合成复用原则

1. 优先使用组合和聚合来实现, 之后才考虑使用继承实现
2. 继承复用: 简单&易实现
   - 破坏了类的封装性: 父类对子类是透明的
   - 子类与父类的耦合度高: 父类的任何改变都会引起子类的改变
   - 限制了复用的灵活性: 从父类继承而来的实现是编译时已经定义, 所以在运行时不可能发生变化
   - 不能多继承
3. 合成/聚合复用
   - 类的封装性: 成员对象的内部细节是新对象看不见的
   - 对象间的耦合度低: 声明成抽象成员
   - 复用的灵活性高: 可以在运行时动态进行, 新对象可以动态地引用与成分对象类型相同的对象
4. 举例: 汽车分类管理{颜色+能源}
   ![avatar](/static/image/pattern/prin-crp.png)
